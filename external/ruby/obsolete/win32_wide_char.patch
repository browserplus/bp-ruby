diff -ur ruby-1.8.7-p22.orig/file.c ruby-1.8.7-p22/file.c
--- ruby-1.8.7-p22.orig/file.c	Wed Oct  8 00:50:55 2008
+++ ruby-1.8.7-p22/file.c	Wed Oct  8 22:39:46 2008
@@ -898,8 +898,20 @@
 # if defined(_MSC_VER) || defined(__MINGW32__)
     mode &= ~1;
 # endif
+#ifdef _WIN32
+    {
+        int x = 0;
+        if (path) {
+            wchar_t * wpath = utf8ToWide(path);
+            x = _waccess(wpath, mode);
+            free(wpath);
+        }
+        return x;
+    }
+#else
     return access(path, mode);
 #endif
+#endif
 }
 #endif
 
@@ -4375,6 +4387,7 @@
 }
 #endif
 
+#include "win32/win32.h"
 static int
 file_load_ok(file)
     const char *file;
@@ -4382,6 +4395,7 @@
     FILE *f;
 
     if (!file) return 0;
+/*     dumpUTF8ToConsole("Opening file", file); */
     f = fopen(file, "r");
     if (f == NULL) return 0;
     fclose(f);
diff -ur ruby-1.8.7-p22.orig/io.c ruby-1.8.7-p22/io.c
--- ruby-1.8.7-p22.orig/io.c	Wed Oct  8 00:50:55 2008
+++ ruby-1.8.7-p22/io.c	Wed Oct  8 18:01:20 2008
@@ -2892,6 +2892,22 @@
     return NULL;		/* not reached */
 }
 
+static int open_wrapper(const char * fname, int flags, unsigned int mode)
+{
+    int fd = -1;
+#ifdef _WIN32
+    if (fname) {
+        wchar_t * wPath = utf8ToWide(fname);
+        fd = _wopen(wPath, flags, mode);
+        free(wPath);
+    }
+#else
+    fd = open(fname, flags, mode);
+#endif
+    return fd;
+}
+
+
 static int
 rb_sysopen(fname, flags, mode)
     char *fname;
@@ -2899,12 +2915,11 @@
     unsigned int mode;
 {
     int fd;
-
-    fd = open(fname, flags, mode);
+    fd = open_wrapper(fname, flags, mode);
     if (fd < 0) {
 	if (errno == EMFILE || errno == ENFILE) {
 	    rb_gc();
-	    fd = open(fname, flags, mode);
+	    fd = open_wrapper(fname, flags, mode);
 	}
 	if (fd < 0) {
 	    rb_sys_fail(fname);
@@ -3441,8 +3456,9 @@
     VALUE *argv;
     VALUE klass;
 {
-    VALUE io = rb_class_new_instance(argc, argv, klass);
+    VALUE io;
 
+    io = rb_class_new_instance(argc, argv, klass);
     if (rb_block_given_p()) {
 	return rb_ensure(rb_yield, io, io_close, io);
     }
diff -ur ruby-1.8.7-p22.orig/lib/mkmf.rb ruby-1.8.7-p22/lib/mkmf.rb
--- ruby-1.8.7-p22.orig/lib/mkmf.rb	Wed Oct  8 00:50:57 2008
+++ ruby-1.8.7-p22/lib/mkmf.rb	Wed Oct  8 18:01:20 2008
@@ -296,7 +296,7 @@
 def create_tmpsrc(src)
   src = yield(src) if block_given?
   src = src.gsub(/[ \t]+$/, '').gsub(/\A\n+|^\n+$/, '').sub(/[^\n]\z/, "\\&\n")
-  open(CONFTEST_C, "wb") do |cfile|
+  open(CONFTEST_C, "w") do |cfile|
     cfile.print src
   end
   src
@@ -1457,7 +1457,7 @@
 
   dllib = target ? "$(TARGET).#{CONFIG['DLEXT']}" : ""
   staticlib = target ? "$(TARGET).#$LIBEXT" : ""
-  mfile = open("Makefile", "wb")
+  mfile = open("Makefile", "w")
   mfile.print configuration(srcprefix)
   mfile.print "
 libpath = #{($DEFLIBPATH|$LIBPATH).join(" ")}
diff -ur ruby-1.8.7-p22.orig/ruby.c ruby-1.8.7-p22/ruby.c
--- ruby-1.8.7-p22.orig/ruby.c	Wed Oct  8 00:51:12 2008
+++ ruby-1.8.7-p22/ruby.c	Wed Oct  8 18:01:20 2008
@@ -112,9 +112,9 @@
 
 extern VALUE rb_load_path;
 
-#ifndef CharNext		/* defined as CharNext[AW] on Windows. */
+//#ifndef CharNext		/* defined as CharNext[AW] on Windows. */
 #define CharNext(p) ((p) + mblen(p, RUBY_MBCHAR_MAXSIZE))
-#endif
+//#endif
 
 #if defined DOSISH || defined __CYGWIN__
 static inline void
@@ -137,6 +137,8 @@
     char *ptr;
     VALUE ret;
 
+/*     dumpUTF8ToConsole("mangling", s); */
+
     if (!newp && !notfound) {
 	newp = getenv("RUBYLIB_PREFIX");
 	if (newp) {
@@ -159,6 +161,7 @@
 	}
     }
     if (!newp || l < oldl || strncasecmp(oldp, s, oldl) != 0) {
+/*     dumpUTF8ToConsole("mangled", s); */
 	return rb_str_new(s, l);
     }
     ret = rb_str_new(0, l + newl - oldl);
@@ -166,6 +169,7 @@
     memcpy(ptr, newp, newl);
     memcpy(ptr + newl, s + oldl, l - oldl);
     ptr[l + newl - oldl] = 0;
+/*     dumpUTF8ToConsole("mangled", ptr); */
     return ret;
 }
 
@@ -240,6 +244,7 @@
 ruby_incpush(path)
     const char *path;
 {
+/*     dumpUTF8ToConsole("pushing", path); */
     if (path == 0)
 	return;
     push_include(path);
diff -ur ruby-1.8.7-p22.orig/win32/win32.c ruby-1.8.7-p22/win32/win32.c
--- ruby-1.8.7-p22.orig/win32/win32.c	Wed Oct  8 00:51:16 2008
+++ ruby-1.8.7-p22/win32/win32.c	Wed Oct  8 18:01:20 2008
@@ -94,6 +94,58 @@
 #define rb_w32_open_osfhandle(osfhandle, flags) _open_osfhandle(osfhandle, flags)
 #endif
 
+// utility routines to go from 
+wchar_t *
+utf8ToWide(const char * sIn)
+{
+    wchar_t * rval = NULL;
+    wchar_t wcBuf[2048];
+
+    int nRtn = MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, sIn, 
+                                   -1, wcBuf, 2048);
+    if (nRtn) {
+        rval = (wchar_t *) calloc(nRtn +1, sizeof(wchar_t));
+        memcpy((void *) rval, (void *) wcBuf, nRtn * sizeof(wchar_t));
+    }
+    return rval;
+}
+
+char *
+wideToUtf8(const wchar_t * wsIn)
+{
+    char * rval = NULL;
+    char cBuf[2048];
+    
+    int nRtn = WideCharToMultiByte(CP_UTF8, 0, wsIn, -1,
+                                   cBuf, 2048, 0, 0 );
+    if (nRtn) rval = strdup(cBuf);
+
+    return rval;
+}
+
+/* debug routine */
+void
+dumpUTF8ToConsole(const char * desc, const char * utf8String)
+{
+    DWORD junk;
+    wchar_t * buf = NULL;
+    char * mbuf = (char *) malloc(strlen(desc) + strlen(utf8String) + 4);
+    memcpy((void *) mbuf, (void *) desc, strlen(desc));
+    memcpy((void *) (mbuf + strlen(desc)), (void *) ": ", 2);    
+    memcpy((void *) (mbuf + strlen(desc) + 2), (void *) utf8String,
+           strlen(utf8String));    
+    mbuf[strlen(desc) + strlen(utf8String) + 2] = '\n';
+    mbuf[strlen(desc) + strlen(utf8String) + 3] = 0;
+    buf = utf8ToWide(mbuf);
+    free(mbuf);
+    (void) WriteConsoleW(GetStdHandle(STD_OUTPUT_HANDLE),
+                         buf,
+                         wcslen(buf),
+                         &junk,
+                         NULL);
+    free(buf);
+}
+
 /* errno mapping */
 static struct {
     DWORD winerr;
@@ -392,55 +444,57 @@
 static void
 init_env(void)
 {
-    char env[_MAX_PATH];
+    wchar_t env[_MAX_PATH];
     DWORD len;
     BOOL f;
     LPITEMIDLIST pidl;
 
-    if (!GetEnvironmentVariable("HOME", env, sizeof(env))) {
-	f = FALSE;
-	if (GetEnvironmentVariable("HOMEDRIVE", env, sizeof(env)))
-	    len = strlen(env);
-	else
-	    len = 0;
-	if (GetEnvironmentVariable("HOMEPATH", env + len, sizeof(env) - len) || len) {
-	    f = TRUE;
-	}
-	else if (GetEnvironmentVariable("USERPROFILE", env, sizeof(env))) {
-	    f = TRUE;
-	}
-	else if (SHGetSpecialFolderLocation(NULL, CSIDL_PERSONAL, &pidl) == 0) {
-	    LPMALLOC alloc;
-	    f = SHGetPathFromIDList(pidl, env);
-	    SHGetMalloc(&alloc);
-	    alloc->lpVtbl->Free(alloc, pidl);
-	    alloc->lpVtbl->Release(alloc);
-	}
-	if (f) {
-	    char *p = env;
-	    while (*p) {
-		if (*p == '\\') *p = '/';
-		p = CharNext(p);
-	    }
-	    if (p - env == 2 && env[1] == ':') {
-		*p++ = '/';
-		*p = 0;
-	    }
-	    SetEnvironmentVariable("HOME", env);
-	}
+    // yes!  I leak!
+    if (!GetEnvironmentVariableW(utf8ToWide("HOME"), env, sizeof(env))) {
+        f = FALSE;
+
+        if (GetEnvironmentVariableW(utf8ToWide("HOMEDRIVE"), env, sizeof(env)))
+            len = wcslen(env);
+        else
+            len = 0;
+        if (GetEnvironmentVariableW(utf8ToWide("HOMEPATH"), env + len, sizeof(env) - len) || len) {
+            f = TRUE;
+        }
+        else if (GetEnvironmentVariableW(utf8ToWide("USERPROFILE"), env, sizeof(env))) {
+            f = TRUE;
+        }
+        else if (SHGetSpecialFolderLocation(NULL, CSIDL_PERSONAL, &pidl) == 0) {
+            LPMALLOC alloc;
+            f = SHGetPathFromIDListW(pidl, env);
+            SHGetMalloc(&alloc);
+            alloc->lpVtbl->Free(alloc, pidl);
+            alloc->lpVtbl->Release(alloc);
+        }
+        if (f) {
+            wchar_t *p = env;
+            while (*p) {
+                if (*p == '\\') *p = '/';
+                p = CharNextW(p);
+            }
+            if (p - env == 2 && env[1] == ':') {
+                *p++ = '/';
+                *p = 0;
+            }
+            SetEnvironmentVariableW(utf8ToWide("HOME"), env);
+        }
     }
 
-    if (!GetEnvironmentVariable("USER", env, sizeof env)) {
-	if (GetEnvironmentVariable("USERNAME", env, sizeof env) ||
-	    GetUserName(env, (len = sizeof env, &len))) {
-	    SetEnvironmentVariable("USER", env);
-	}
-	else {
-	    NTLoginName = "<Unknown>";
-	    return;
-	}
+    if (!GetEnvironmentVariableW(utf8ToWide("USER"), env, sizeof env)) {
+        if (GetEnvironmentVariableW(utf8ToWide("USERNAME"), env, sizeof env) ||
+            GetUserNameW(env, (len = sizeof env, &len))) {
+            SetEnvironmentVariableW(utf8ToWide("USER"), env);
+        }
+        else {
+            NTLoginName = "<Unknown>";
+            return;
+        }
     }
-    NTLoginName = strdup(env);
+    NTLoginName = wideToUtf8(env);
 }
 
 //
@@ -1497,8 +1551,12 @@
     //
     // do the FindFirstFile call
     //
-
-    fh = FindFirstFile(scanname, &fd);
+    {
+        wchar_t * scannamew = utf8ToWide(scanname);
+        fh = FindFirstFileW(scannamew, &fd);
+        free(scannamew);
+    }
+    
     if (fh == INVALID_HANDLE_VALUE) {
 	errno = map_errno(GetLastError());
 	free(p);
@@ -3178,14 +3236,18 @@
 }
 
 int
-rb_w32_rename(const char *oldpath, const char *newpath)
+rb_w32_rename(const char *oldpathUTF8, const char *newpathUTF8)
 {
     int res = 0;
     int oldatts;
     int newatts;
+    wchar_t * oldpath, * newpath;
 
-    oldatts = GetFileAttributes(oldpath);
-    newatts = GetFileAttributes(newpath);
+    oldpath = utf8ToWide(oldpathUTF8);
+    newpath = utf8ToWide(newpathUTF8);    
+
+    oldatts = GetFileAttributesW(oldpath);
+    newatts = GetFileAttributesW(newpath);
 
     if (oldatts == -1) {
 	errno = map_errno(GetLastError());
@@ -3194,9 +3256,9 @@
 
     RUBY_CRITICAL({
 	if (newatts != -1 && newatts & FILE_ATTRIBUTE_READONLY)
-	    SetFileAttributesA(newpath, newatts & ~ FILE_ATTRIBUTE_READONLY);
+	    SetFileAttributesW(newpath, newatts & ~ FILE_ATTRIBUTE_READONLY);
 
-	if (!MoveFile(oldpath, newpath))
+	if (!MoveFileW(oldpath, newpath))
 	    res = -1;
 
 	if (res) {
@@ -3204,13 +3266,13 @@
 	      case ERROR_ALREADY_EXISTS:
 	      case ERROR_FILE_EXISTS:
 		if (IsWinNT()) {
-		    if (MoveFileEx(oldpath, newpath, MOVEFILE_REPLACE_EXISTING))
+		    if (MoveFileExW(oldpath, newpath, MOVEFILE_REPLACE_EXISTING))
 			res = 0;
 		} else {
 		    for (;;) {
-			if (!DeleteFile(newpath) && GetLastError() != ERROR_FILE_NOT_FOUND)
+			if (!DeleteFileW(newpath) && GetLastError() != ERROR_FILE_NOT_FOUND)
 			    break;
-			else if (MoveFile(oldpath, newpath)) {
+			else if (MoveFileW(oldpath, newpath)) {
 			    res = 0;
 			    break;
 			}
@@ -3222,9 +3284,12 @@
 	if (res)
 	    errno = map_errno(GetLastError());
 	else
-	    SetFileAttributes(newpath, oldatts);
+	    SetFileAttributesW(newpath, oldatts);
     });
 
+    if (oldpath) free(oldpath);
+    if (newpath) free(newpath);    
+
     return res;
 }
 
@@ -3320,7 +3385,10 @@
 winnt_stat(const char *path, struct stat *st)
 {
     HANDLE h;
-    WIN32_FIND_DATA wfd;
+    WIN32_FIND_DATAW wfd;
+    wchar_t * wpath = NULL;
+    
+    if (path) wpath = utf8ToWide(path);
 
     memset(st, 0, sizeof(struct stat));
     st->st_nlink = 1;
@@ -3329,7 +3397,7 @@
 	errno = ENOENT;
 	return -1;
     }
-    h = FindFirstFile(path, &wfd);
+    h = FindFirstFileW(wpath, &wfd);
     if (h != INVALID_HANDLE_VALUE) {
 	FindClose(h);
 	st->st_mode  = fileattr_to_unixmode(wfd.dwFileAttributes, path);
@@ -3341,7 +3409,7 @@
     else {
 	// If runtime stat(2) is called for network shares, it fails on WinNT.
 	// Because GetDriveType returns 1 for network shares. (Win98 returns 4)
-	DWORD attr = GetFileAttributes(path);
+	DWORD attr = GetFileAttributesW(wpath);
 	if (attr == -1) {
 	    errno = map_errno(GetLastError());
 	    return -1;
@@ -3352,6 +3420,8 @@
     st->st_dev = st->st_rdev = (isalpha(path[0]) && path[1] == ':') ?
 	toupper(path[0]) - 'A' : _getdrive() - 1;
 
+    if (wpath) free(wpath);
+
     return 0;
 }
 
@@ -3389,8 +3459,13 @@
 	    strcat(buf1, "\\");
     } else if (*end == '\\' || (buf1 + 1 == end && *end == ':'))
 	strcat(buf1, ".");
-
-    ret = IsWinNT() ? winnt_stat(buf1, st) : stat(buf1, st);
+    
+    {
+        wchar_t * wpath = utf8ToWide(buf1);
+        ret = IsWinNT() ? winnt_stat(buf1, st) : _wstat32(wpath, st);
+        free(wpath);
+    }
+    
     if (ret == 0) {
 	st->st_mode &= ~(S_IWGRP | S_IWOTH);
     }
@@ -3925,8 +4000,12 @@
 {
     HANDLE hFile;
     FILETIME atime, mtime;
+    wchar_t * wpath = NULL;
     struct stat stat;
     int ret = 0;
+    
+    if (path) wpath = utf8ToWide(path);
+
 
     if (rb_w32_stat(path, &stat)) {
 	return -1;
@@ -3946,10 +4025,10 @@
     }
 
     RUBY_CRITICAL({
-	const DWORD attr = GetFileAttributes(path);
+	const DWORD attr = GetFileAttributesW(wpath);
 	if (attr != (DWORD)-1 && (attr & FILE_ATTRIBUTE_READONLY))
-	    SetFileAttributes(path, attr & ~FILE_ATTRIBUTE_READONLY);
-	hFile = CreateFile(path, GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+	    SetFileAttributesW(wpath, attr & ~FILE_ATTRIBUTE_READONLY);
+	hFile = CreateFileW(wpath, GENERIC_WRITE, 0, 0, OPEN_EXISTING,
 			   IsWin95() ? 0 : FILE_FLAG_BACKUP_SEMANTICS, 0);
 	if (hFile == INVALID_HANDLE_VALUE) {
 	    errno = map_errno(GetLastError());
@@ -3963,9 +4042,11 @@
 	    CloseHandle(hFile);
 	}
 	if (attr != (DWORD)-1 && (attr & FILE_ATTRIBUTE_READONLY))
-	    SetFileAttributes(path, attr);
+	    SetFileAttributesW(wpath, attr);
     });
 
+    if (wpath) free(wpath);
+
     return ret;
 }
 
@@ -3992,58 +4073,79 @@
 int
 rb_w32_mkdir(const char *path, int mode)
 {
+    wchar_t * wpath = NULL;
     int ret = -1;
+    
+    if (path) wpath = utf8ToWide(path);
+
     RUBY_CRITICAL(do {
-	if (CreateDirectory(path, NULL) == FALSE) {
+	if (CreateDirectoryW(wpath, NULL) == FALSE) {
 	    errno = map_errno(GetLastError());
 	    break;
 	}
-	if (chmod(path, mode) == -1) {
-	    RemoveDirectory(path);
+	if (_wchmod(wpath, mode) == -1) {
+	    RemoveDirectoryW(wpath);
 	    break;
 	}
 	ret = 0;
     } while (0));
+    
+    if (wpath) free(wpath);
+
     return ret;
 }
 
 int
 rb_w32_rmdir(const char *path)
 {
+    wchar_t * wpath = NULL;
     int ret = 0;
+
+    if (path) wpath = utf8ToWide(path);
+
     RUBY_CRITICAL({
-	const DWORD attr = GetFileAttributes(path);
+	const DWORD attr = GetFileAttributesW(wpath);
 	if (attr != (DWORD)-1 && (attr & FILE_ATTRIBUTE_READONLY)) {
-	    SetFileAttributes(path, attr & ~FILE_ATTRIBUTE_READONLY);
+	    SetFileAttributesW(wpath, attr & ~FILE_ATTRIBUTE_READONLY);
 	}
-	if (RemoveDirectory(path) == FALSE) {
+	if (RemoveDirectoryW(wpath) == FALSE) {
 	    errno = map_errno(GetLastError());
 	    ret = -1;
 	    if (attr != (DWORD)-1 && (attr & FILE_ATTRIBUTE_READONLY)) {
-		SetFileAttributes(path, attr);
+            SetFileAttributesW(wpath, attr);
 	    }
 	}
     });
+
+    if (wpath) free(wpath);
+    
     return ret;
 }
 
 int
 rb_w32_unlink(const char *path)
 {
+    wchar_t * wpath = NULL;
     int ret = 0;
+    
+    if (path) wpath = utf8ToWide(path);
+
     RUBY_CRITICAL({
-	const DWORD attr = GetFileAttributes(path);
+	const DWORD attr = GetFileAttributesW(wpath);
 	if (attr != (DWORD)-1 && (attr & FILE_ATTRIBUTE_READONLY)) {
-	    SetFileAttributes(path, attr & ~FILE_ATTRIBUTE_READONLY);
+	    SetFileAttributesW(wpath, attr & ~FILE_ATTRIBUTE_READONLY);
 	}
-	if (DeleteFile(path) == FALSE) {
+	if (DeleteFileW(wpath) == FALSE) {
 	    errno = map_errno(GetLastError());
 	    ret = -1;
 	    if (attr != (DWORD)-1 && (attr & FILE_ATTRIBUTE_READONLY)) {
-		SetFileAttributes(path, attr);
+            SetFileAttributesW(wpath, attr);
 	    }
 	}
     });
+
+    if (wpath) free(wpath);
+    
     return ret;
 }
 
@@ -4067,22 +4169,33 @@
 // Fix bcc32's stdio bug
 //
 
-#ifdef __BORLANDC__
+#if defined(__BORLANDC__) || defined(BP_WIDE_CHAR)
 static int
 too_many_files()
 {
-    FILE *f;
-    for (f = _streams; f < _streams + _nfile; f++) {
-	if (f->fd < 0) return 0;
-    }
-    return 1;
+    return 0;
+/*     FILE *f; */
+/*     for (f = _streams; f < _streams + _nfile; f++) { */
+/* 	if (f->fd < 0) return 0; */
+/*     } */
+/*     return 1; */
 }
 
 #undef fopen
 FILE *
 rb_w32_fopen(const char *path, const char *mode)
 {
-    FILE *f = (errno = 0, fopen(path, mode));
+    FILE *f = NULL;
+    wchar_t * wpath = NULL, *wmode = NULL;
+
+/*     dumpUTF8ToConsole("fopen: ", path); */
+
+    if (path) wpath = utf8ToWide(path);
+    if (mode) wmode = utf8ToWide(mode);
+    f = (errno = 0, _wfopen(wpath, wmode));
+    if (wpath) free(wpath);
+    if (wmode) free(wmode);
+    
     if (f == NULL && errno == 0) {
 	if (too_many_files())
 	    errno = EMFILE;
@@ -4106,7 +4219,15 @@
 FILE *
 rb_w32_fsopen(const char *path, const char *mode, int shflags)
 {
-    FILE *f = (errno = 0, _fsopen(path, mode, shflags));
+    FILE *f = NULL;
+    wchar_t * wpath = NULL, * wmode = NULL;
+/*     dumpUTF8ToConsole("_wfsopen: ", path); */
+
+    if (path) wpath = utf8ToWide(path);
+    if (mode) wmode = utf8ToWide(mode);
+    f = (errno = 0, _wfsopen(wpath, wmode, shflags));
+    if (wpath) free(wpath);
+    if (wmode) free(wmode);
     if (f == NULL && errno == 0) {
 	if (too_many_files())
 	    errno = EMFILE;
diff -ur ruby-1.8.7-p22.orig/win32/win32.h ruby-1.8.7-p22/win32/win32.h
--- ruby-1.8.7-p22.orig/win32/win32.h	Wed Oct  8 00:51:16 2008
+++ ruby-1.8.7-p22/win32/win32.h	Wed Oct  8 18:01:20 2008
@@ -1,6 +1,8 @@
 #ifndef RUBY_WIN32_H
 #define RUBY_WIN32_H
 
+#define BP_WIDE_CHAR
+
 /*
  *  Copyright (c) 1993, Intergraph Corporation
  *
@@ -118,7 +120,7 @@
 #define write(f, b, s)		rb_w32_write(f, b, s)
 #define getpid()		rb_w32_getpid()
 #define sleep(x)		rb_w32_sleep((x)*1000)
-#ifdef __BORLANDC__
+#if defined(__BORLANDC__) || defined(BP_WIDE_CHAR)
 #define creat(p, m)		_creat(p, m)
 #define eof()			_eof()
 #define filelength(h)		_filelength(h)
@@ -219,7 +221,7 @@
 extern int rb_w32_rmdir(const char *);
 extern int rb_w32_unlink(const char*);
 
-#ifdef __BORLANDC__
+#if defined(__BORLANDC__) || defined(BP_WIDE_CHAR)
 extern FILE *rb_w32_fopen(const char *, const char *);
 extern FILE *rb_w32_fdopen(int, const char *);
 extern FILE *rb_w32_fsopen(const char *, const char *, int);
@@ -542,6 +544,12 @@
 size_t rb_w32_write(int, const void *, size_t);
 int  rb_w32_utime(const char *, struct utimbuf *);
 #define Sleep(msec) (void)rb_w32_sleep(msec)
+
+void
+dumpUTF8ToConsole(const char * desc, const char * utf8String);
+
+wchar_t * utf8ToWide(const char * sIn);
+char * wideToUtf8(const wchar_t * wsIn);
 
 /*
 == ***CAUTION***
